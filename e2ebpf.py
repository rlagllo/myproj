# -*- coding: utf-8 -*-
"""E2EBPF

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F5SaFOjm9rL3XhWEjIJy-bhyYfESwwEb
"""

print("Hello")

import keras
import tensorflow as tf

#Constants
KERNEL_SIZE = 3     #3x3 kernel
POOL_SIZE = (2, 2)  #Pooling Size
KERNEL_SIZE_TRANS = (2, 2)  #TransposeConvolution kernel size
INPUT_SHAPE = (32, 32)

class DoubleConvBlock(keras.Layer):
    def __init__(self, filterNum):
        super(DoubleConvBlock, self).__init__()

        self.conv2D = keras.layers.Conv2D(filterNum, KERNEL_SIZE, padding='same')
        self.batchNormalization = keras.layers.BatchNormalization()
        self.activation = keras.layers.Activation('relu')

    def call(self, inputs):
        _temp = self.conv2D(inputs)
        _temp = self.batchNormalization(_temp)
        _temp = self.activation(_temp)

        _temp = self.conv2D(inputs)
        _temp = self.batchNormalization(_temp)
        _temp = self.activation(_temp)

        outputs = _temp

        return outputs

class EncoderBlock(keras.Layer):
    def __init__(self, filterNum):
        super(EncoderBlock, self).__init__()

        self.doubleConvBlock = DoubleConvBlock(filterNum)
        self.pool = keras.layers.MaxPooling2D(POOL_SIZE)

    def call(self, inputs):
        skip = self.doubleConvBlock(inputs)     #skip for decoder block
        outputs = self.pool(skip)               #output for next block
        return skip, outputs

class DropBlock(keras.Layer):
    def __init__(self, filterNum):
        super(DropBlock, self).__init__()

        self.doubleConvBlock = DoubleConvBlock(filterNum)

    def call(self, inputs):
        drops = self.doubleConvBlock(inputs)
        return drops

class DecoderBlock(keras.Layer):
    def __init__(self, filterNum):
        super(DecoderBlock, self).__init__()

        self.upConv = keras.layers.Conv2DTranspose(filterNum * 2, KERNEL_SIZE_TRANS, strides=2, padding='same')
        self.doubleConvBlock = DoubleConvBlock(filterNum)

    def call(self, inputs, skip):
        _temp = self.upConv(inputs)
        _temp = keras.layers.Concatenate()([_temp, skip])
        outputs = self.doubleConvBlock(_temp)

class UNET(keras.Model):
    def __init__(self, classNum=1):
        super(UNET, self).__init__()
        #self.input_layer = keras.Input(shape=inputShape)

        #Encoder
        self.e1 = EncoderBlock(32)
        self.e2 = EncoderBlock(64)
        self.e3 = EncoderBlock(128)
        self.e4 = EncoderBlock(256)

        #Dropout
        self.drop = DropBlock(512)

        #Decoder
        self.d1 = DecoderBlock(256)
        self.d2 = DecoderBlock(128)
        self.d3 = DecoderBlock(64)
        self.d4 = DecoderBlock(32)

        #Output
        self.outputs = keras.layers.Conv2D(classNum, 1, padding='same', activation='tanh')

    def call(self, inputs):
        #Encoder
        skip1, pass1 = self.e1(inputs)
        skip2, pass2 = self.e2(pass1)
        skip3, pass3 = self.e3(pass2)
        skip4, pass4 = self.e4(pass3)

        #Dropout
        drop = self.drop(pass4)

        #Decoder
        decode1 = self.d1(drop, skip4)
        decode2 = self.d2(decode1, skip3)
        decode3 = self.d3(decode2, skip2)
        decode4 = self.d4(decode3, skip1)

        #Output
        outputs = self.outputs(decode4)

        return outputs

import matplotlib.pyplot as plt
import numpy as np
import cv2

def unpickle(file):
    import pickle
    with open(file, 'rb') as fo:
        dict = pickle.load(fo, encoding='bytes')
    return dict


#학습 데이터
test_labels_ = unpickle('/content/data_batch_1')
test_labels = []
test_data = []
for datum in test_labels_[b'data']:
    _temp = datum.reshape(3,1024)
    imgR = _temp[0].reshape(32,32)
    imgG = _temp[1].reshape(32,32)
    imgB = _temp[2].reshape(32,32)

    imgColored = np.dstack([imgR, imgG, imgB])
    imgGray = cv2.cvtColor(imgColored, cv2.COLOR_BGR2GRAY)
    imgBlurred = cv2.blur(imgGray, (3, 3))

    test_labels = np.stack
    test_labels.append(imgGray)
    test_data.append(imgBlurred)

#예측 데이터
sample_labels_ = unpickle('/content/test_batch')
sample_labels = list()
sample_data = list()
for datum in sample_labels_[b'data']:
    _temp = datum.reshape(3,1024)
    imgR = _temp[0].reshape(32,32)
    imgG = _temp[1].reshape(32,32)
    imgB = _temp[2].reshape(32,32)

    imgColored = np.dstack([imgR, imgG, imgB])
    imgGray = cv2.cvtColor(imgColored, cv2.COLOR_BGR2GRAY)
    imgBlurred = cv2.blur(imgGray, (3, 3))

    sample_labels.append(imgGray)
    sample_data.append(imgBlurred)

# class Trainer:
#   def __init__(self, model, epochs, )

model = UNET()
model.summary()
#컴파일
model.compile(optimizer=keras.optimizers.Adam(learning_rate=1e-4, ema_momentum=0.99),
              loss=keras.losses.mean_squared_error,
              metrics=['accuracy'])     #mse임. rmse로 바꿔야 됨

training_data = np.a

model.fit(
    test_data[0:4],
    test_labels[0:4],
    batch_size=1000,
    epochs = 100,
)