# -*- coding: utf-8 -*-
"""preprocessing_codes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qh6rvqBQuNq2eyjHobSNoK_43pHIBTFX
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
import h5py
#from google.colab import drive
#drive.mount('/content/drive')
import os
os.chdir('C:\\Users\\김해창\\Desktop\\ANSYS_HW_CGNS')
#no such files or directory 나올 때:

# Load the CGNS file
#case_index = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
#for i in range (len(case_index)):
 #   file_path = 'case' + str(case_index[i])+'_U_'+str(case_index[i])+'ms.cgns'

case_index = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for i in range (len(case_index)):
    file_path = 'project_v=' + str(case_index[i])+'.cgns'  #파일명

    with h5py.File(file_path, 'r') as f:    #파일 정보 받아오기
        # Extract grid coordinates
        x = f['Base/Zone/GridCoordinates/CoordinateX/ data'][:]
        y = f['Base/Zone/GridCoordinates/CoordinateY/ data'][:]
        z = f['Base/Zone/GridCoordinates/CoordinateZ/ data'][:]

        # Extract velocity magnitude
        velocity_magnitude = f['Base/Zone/FlowSolution.N:1/VelocityMagnitude/ data'][:]

    # Determine the Z mid-plane and filter data
    z_mid = (z.max() + z.min()) / 2
    tolerance = 0.01 * (z.max() - z.min())  # Narrow slice around the midpoint
    slice_indices = (z > z_mid - tolerance) & (z < z_mid + tolerance)

    x_slice = x[slice_indices]
    y_slice = y[slice_indices]
    velocity_slice = velocity_magnitude[slice_indices]

    # Generate a grid for the contour plot
    grid_x, grid_y = np.linspace(x_slice.min(), x_slice.max(), 500), np.linspace(y_slice.min(), y_slice.max(), 500)
    grid_x, grid_y = np.meshgrid(grid_x, grid_y)

    # Interpolate the velocity magnitude onto the grid
    grid_velocity = griddata((x_slice, y_slice), velocity_slice, (grid_x, grid_y), method='linear')

    # Create a contour plot
    plt.figure(figsize=(10, 8))
    contour = plt.contourf(grid_x, grid_y, grid_velocity, levels=50, cmap='jet', vmin=0, vmax=15)  # Using 'jet' cmap

    # Remove axes and ticks
    plt.axis('off')

    # Set aspect ratio to equal
    plt.gca().set_aspect('equal', adjustable='box')

    # Crop the image tightly to the domain
    plt.xlim(x_slice.min(), x_slice.max())
    plt.ylim(y_slice.min(), y_slice.max())

    # Save the contour plot without padding or axes
    contour_output_path = str(case_index[i])+".png"
    plt.savefig(contour_output_path, dpi=300, bbox_inches='tight', pad_inches=0)
    plt.close()

    print(f"Trimmed contour plot saved to {contour_output_path}")



import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
import h5py

# Load the CGNS file, gray 만들기?
file_path = 'project_v=1.cgns'

with h5py.File(file_path, 'r') as f:
    # Extract grid coordinates
    x = f['Base/Zone/GridCoordinates/CoordinateX/ data'][:]
    y = f['Base/Zone/GridCoordinates/CoordinateY/ data'][:]
    z = f['Base/Zone/GridCoordinates/CoordinateZ/ data'][:]

    # Extract velocity magnitude
    velocity_magnitude = f['Base/Zone/FlowSolution.N:1/VelocityMagnitude/ data'][:]

# Determine the Z mid-plane and filter data
z_mid = (z.max() + z.min()) / 2
tolerance = 0.01 * (z.max() - z.min())  # Narrow slice around the midpoint
slice_indices = (z > z_mid - tolerance) & (z < z_mid + tolerance)

x_slice = x[slice_indices]
y_slice = y[slice_indices]
velocity_slice = velocity_magnitude[slice_indices]

# Generate a grid for the contour plot
grid_x, grid_y = np.linspace(x_slice.min(), x_slice.max(), 500), np.linspace(y_slice.min(), y_slice.max(), 500)
grid_x, grid_y = np.meshgrid(grid_x, grid_y)

# Interpolate the velocity magnitude onto the grid
grid_velocity = griddata((x_slice, y_slice), velocity_slice, (grid_x, grid_y), method='linear')

# Create a mask: 0 for velocity 0, 1 for velocity > 0
velocity_mask = np.where(grid_velocity > 0, 1, 0)

# Create the plot
plt.figure(figsize=(10, 8))
plt.imshow(
    velocity_mask,
    extent=[x_slice.min(), x_slice.max(), y_slice.min(), y_slice.max()],
    origin='lower',
    cmap='gray',  # Black and white colormap
    interpolation='none'
)

# Remove axes and ticks
plt.axis('off')

# Set aspect ratio to equal
plt.gca().set_aspect('equal', adjustable='box')

# Save the plot without padding or axes
output_path = "velocity_field_binary_mask.png"
plt.savefig(output_path, dpi=300, bbox_inches='tight', pad_inches=0)
plt.close()

print(f"Binary mask plot saved to {output_path}")